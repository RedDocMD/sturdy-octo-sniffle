[{"id":0,"href":"/sturdy-octo-sniffle/docs/report/","title":"Final Report","section":"Docs","content":"Making Smart Pointer Checkers default checkers in the Static Analyzer #  Information #   Name: Deep Majumder Email: deep.majumder2019@gmail.com Mentors: Artem Dergachev, Valeriy Savchenko, Gábor Horváth, Raphael Isemann Patches: On Github (if this link is broken, please use the following search term on Github: repo:llvm/llvm-project author:RedDocMD author-date:2021-05-17..2021-08-23)  Overview #  This project aims to complete the SmartPtrChecker and thus SmartPtrModeling checkers to detect null-dereferences of the std::unique_ptr. This is a continuation of the GSoC 2020 project in the same area.\nDescription #  SmartPtrChecker used to be a checker in the Clang Static Analyzer for detecting \u0026ldquo;simple\u0026rdquo; null dereferences. The GSoC 2020 project improved upon this to provide the SmartPtrModeling checker, which models many of the important operations on std::unique_ptr, such as move, reset, release, convert to bool, etc. This project completes most of the gaps and uncompleted areas in the modelling, including the ubiquitous std::make_unique function and the destructor (which communicates with the MallocChecker to remove false positives). Currently, we are a few bug fixes and some polishing away from making this a default checker (as of Clang 13, it is an alpha checker).\nRevisions #  One aim of this project was to make sure that no method defined on std::unique_ptr is left un-modelled. If we don\u0026rsquo;t, CSA either does:\n Conservative evaluation, which leads to loss of information and possibly warnings being suppressed Inlining, which sometimes leads the CSA to falsely believe that there is a bug in the standard library code (because we have modelled parts of it and are inlining other parts). Since bugs in standard library code are normally suppressed, this leads to other bugs beings suppressed (false-negatives). For example:  void foo() { auto smart = std::unique_ptr\u0026lt;int\u0026gt;(new int(13)); auto raw = new int(29); // There is a leak here. } Without D105821, this used to have no leak warning. The inlining of the destructor of std::unique_ptr led the CSA to falsely believe there was a bug in the destructor code.\nModel comparision methods of std::unique_ptr #  D104616 introduces modelling of comparision operator overloads of std::unique_ptr. It leverages the SValBuilder::evalBinOp to evaluate the result of the operator. More importantly, it attempts to perform a state-split if it is possible.\nModel std::swap specialization for std::unique_ptr #  D104300 models the std::swap specialization for std::unique_ptr. There is an existing swap method on std::unique_ptr, which performs roughly the same thing. Thus, the common code is refactored out and both methods are handled exactly the same way.\nModel \u0026lt;\u0026lt; operator specialization for std::unique_ptr #  D105421 models the \u0026lt;\u0026lt; operator specialization for std::unique_ptr. There is not that much modelling required for this method, other than invalidating the stream region.\nModel std::make_unique and cousins #  D103750 models the quintessential std::make_unique function. In this entire checker, we only account for unique_ptr containing pointers, not arrays - we do the same here as well. The crux of this patch is informing the CSA that we are constructing an object via this function. Ideally this should be handled automatically (as it is for constructors). But here we bail out and simply call ExprEngine::updateObjectsUnderConstruction. Also we ensure that the ProgramState knows that we have a non-null inner pointer in the unique_ptr.\nFix for faulty namespace test and add flag checking #  D106296 prevents a crash we encountered by handling the case where we do not have the declaration of a function and so cannot know its namespace. Also we add the ModelSmartPtrDereference flag check to the previously modelled functions.\nAdd option to SATest.py for extra checkers #  D106739 augments the functionality of the SATest.py script. This script runs the CSA on the projects in the clang/utils/analyzer/projects directory (via a Docker image). By default, the script runs the CSA with only default checkers enabled. This patch adds a flag to enable extra checkers (for our case, the SmartPtrChecker), enabling us to conveniently run test our patches.\nModel destructor for std::unique_ptr #  D105821 models the elephant in the room - the destructor for std::unique_ptr. Although we are just modelling the destructor in this patch, in reality, we have ended up calling the MallocChecker and improving the invalidation scheme in addition to the modelling. We are doing the following steps:\n Enable calling evalCall for destructor-calls (before this patch, only the defaultEvalCall is run) Escape inner pointer on construction and reset Escape all reachable symbols in checkRegionChange Invalidate the inner pointer and remove it from TrackedRegionMap (in both destructor and in reset)  The fuss about invalidation of inner pointer stems from the fact that delete also calls the member destructor (if it exists). Consider the following class:\nclass LameVector { size_t sz = 0; size_t cap = 4; size_t el_sz = 1; unsigned char *buf; public: LameVector() : buf{new unsigned char[cap]} {} ~LameVector() { delete[] buf; } }; void foo() { auto ptr = std::make_unique\u0026lt;LameVector\u0026gt;(); } In this code, LameVector contains an inner pointer, which is freed in its destructor. If we do not invalidate this inner pointer, CSA will think LameVector and hence ptr leaks memory.\nThis is a stop gap measure and it seems to work for the time being. The proper solution is to inline both the member constructor (both during constructor calls and during make_unique) and the member destructor. But we don\u0026rsquo;t yet have a mechanism to \u0026ldquo;evaluate\u0026rdquo; functions from a checker.\nResults #  We have two sources of test projects to run:- projects in the clang/utils/analyzer/projects directory and Webkit. We evaluated checker performance by:\n Running scan-build with and without the patches from this project Running scan-build with SmartPtrChecker enabled and disabled  Projects in clang/utils/analyzer/projects #    On running with and without the patches of this project, no warnings were added or removed. This is somewhat expected since the main false warnings expected to be fixed are from the MallocChecker. This effect is cancelled by the suppressed error detected during inlining of std::unique_ptr destructor.\n  On running with SmartPtrChecker enabled and disabled, some warnings were added, many were removed. The warnings removed were almost all false memory-leak warnings due to the lack of modelling. (drogon, fmt, re2, faiss). oatpp had some \u0026ldquo;C++ move semantics\u0026rdquo; warnings removed, because std::unique_ptr or srd::shared_ptr is perfectly usable and valid after a move. Some warnings were added to duckdb, drogon and re2, all due to custom \u0026ldquo;smart pointers\u0026rdquo; in the codebase.\n  Webkit #    On running with and without the patches of this project, about 250 false memory leaks warnings were removed. As for null-dereference warnings, 6 were removed and 6 added. The ones removed is a question for further investigation.\n  On running with SmartPtrChecker enabled and disabled, about 90 null smart pointer dereference warnings are emitted (including 3 out the 4 mentioned in previous year\u0026rsquo;s report, the fourth was not emitted due to the code being removed). There are still some false positives. These will be areas to look at before declaring that we have a stable checker.\n  Future Work #   Inlined defensive checks: This is a class of false-positives with a really misleading note.  void foo(std::unique_ptr\u0026lt;int\u0026gt; \u0026amp;P) { if (P) {} } int bar(std::unique_ptr\u0026lt;int\u0026gt; Q) { foo(Q); return *Q; // warning: null dereference } The problem is that foo(Q) creates a state split. But CSA uses the state split in foo to conclude in bar() that there exists a path in which Q is null and there is a dereference. We need to make sure that state-splits in other functions don\u0026rsquo;t lead to misleading diagnostics.\n  Polish and commit D105821: This patch has become too bulky and probably needs to be split into two at least (one part for the destructor and the other part for the pointer escape). Also they need tests!\n  Enable the checker by default: Once the previous two tasks are done and the remaining bugs uncovered by WebKit fixed, we can make it a default checker. 😃\n  Model std::shared_ptr and std::weak_ptr: These two can be modelled in a manner similar to std::unique_ptr, ie, with the TrackedRegionMap. In addition, these smart pointers need a ref count to be stored in the GDM. A discussion on how to do this can be found in my GSoC proposal.\n  Running the code #  To run the CSA with SmartPtrChecker enabled:\n\u0026lt;path-to-scan-build\u0026gt; -o . -enable-checker alpha.cplusplus.SmartPtr -analyzer-config cplusplus.SmartPtrModeling:ModelSmartPtrDereference=true clang++ -c \u0026lt;filename\u0026gt; Acknowledgement #  I would like to express my sincere gratitude towards my four mentors - Artem Dergachev, Valeriy Savchenko, Gábor Horváth and Raphael Isemann. They helped me tirelessly throughout the GSoC period, quickly responding to my emails, reviewing my patches and giving advice. They were available for long hours of Skype calls, at often awkward times for them (due to time zone differences). It was a fun three months of learning, coding, struggling, hacking and doing something, perhaps, meaningful.\n"},{"id":1,"href":"/sturdy-octo-sniffle/docs/proposal/","title":"Proposal","section":"Docs","content":"Proposal for \u0026ldquo;Making Smart Pointer Checkers default checkers in the Static Analyzer\u0026rdquo; #  Information #   Name: Deep Majumder Email: deep.majumder2019@gmail.com  Problem Statement #  The Clang Static Analyzer contains a SmartPtrChecker for catching null smart pointer dereference bugs. The data it uses to figure out such cases comes from the SmartPtrModelling checker, which models how a smart pointer behaves. This way, the Static Analyzer can find these bugs without accessing the source code for C++ standard library smart pointers.\nHowever, as of now, std::unique_ptr has been modelled in the SmartPtrModelling (mostly). This leaves us with the following other standard smart pointers:\n std::shared_ptr std::weak_ptr  I intend to enhance and complete the SmartPtrModelling and SmartPtrChecker so that it is ready to move from being an experimental checker to a default checker. To this end I will:\n Remove TODO’s and FIXME’s in std::unique_ptr as well as cover unimplemented methods. Model std::shared_ptr and std::weak_ptr and cover as many possible methods.  As examples of new bugs which will be covered by this project, please see Example 1 and Example 2.\nExample 1: std::shared_ptr constructed null\nstruct A { int field; void foo() { std::cout \u0026lt;\u0026lt; \u0026#34;Field: \u0026#34; \u0026lt;\u0026lt; field \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } A(int f = 0) : field{f} {} }; void deref_bad(std::shared_ptr\u0026lt;A\u0026gt; AS) { AS-\u0026gt;foo(); // Yikes! Null deref here } void maker() { std::shared_ptr\u0026lt;A\u0026gt; AS; deref_bad(AS); } Example 2: std::weak_ptr used after std::shared_ptr it referred to is destructed\nstruct A { int field; void foo() { std::cout \u0026lt;\u0026lt; \u0026#34;Field: \u0026#34; \u0026lt;\u0026lt; field \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } A(int f = 0) : field{f} {} }; void mess() { std::weak_ptr\u0026lt;A\u0026gt; A_Weak; { std::shared_ptr\u0026lt;A\u0026gt; A_Shared = std::make_shared\u0026lt;A\u0026gt;(100); A_Weak = A_Shared; } // A_Shared is dropped here  auto trouble = A_Weak.lock(); // trouble is a null shared_ptr  trouble-\u0026gt;foo(); // Oops! Now that\u0026#39;s trouble } Goals #  At the end of this project:\n The checker for std::unique_ptr dereferences should be in the default checkers list There should be an alpha checker for checking of std::shared_ptr and std::weak_ptr  Thus, the user will have a stable checker for checking null std::unique_ptr dereferences. I hope that this checker will be enabled by default.\nProposed Solution #  Rename the checkers #  SmartPtrModelling should be renamed to something more reflective, like UniquePtrModelling.\nSmartPtrChecker will continue to have the same name, but only std::unique_ptr will be covered by default in the default section of checkers. For shared_ptr, there will be SharedPtrModellling and for weak_ptr there will be WeakPtrModellling. There will be an inter-checker api for connecting the two. I would try to bring SharedPtrModelling to default as well, but WeakPtrChecker would definitely be in the alpha checkers group.\nMethods of std::unique_ptr not covered yet #  From the report of the last year’s GSoC project “Find null smart pointer dereferences with the Static Analyzer”, the following methods are yet to be modelled:\n std::make_unique std::make_unique_for_overwrite Destructor std::swap comparison operators  I intend to complete all of these. These will build on the existing methods in SmartPtrModelling.\nTODO’s and FIXME’s in SmartPtrModelling #  The following table is a list of such flags (as of now) in SmartPtrModelling.cpp:\n   Sl. No. Line number Type Comment     1 170 TODO Update CallDescription to support anonymous calls   2 171 TODO Handle other methods, such as .get() or .release(). But once we do, we\u0026rsquo;d need a visitor to explain null dereferences that are found via such modeling.   3 191 FIXME Once we model std::move for smart pointers clean up this and use that modeling.   4 197 TODO Model this case as well. At least, avoid invalidation of globals.   5 202 TODO Add a note to bug reports describing this decision.   6 359 TODO Make sure to invalidate the region in the Store if we don\u0026rsquo;t have time to model all methods.   7 394 TODO Add support to enable MallocChecker to start tracking the raw pointer.   8 460 TODO Add NoteTag, for how the raw pointer got using \u0026lsquo;get\u0026rsquo; method.    I am currently working on item 7 (D98726) and item 8 (D97183) of the above table. Not all of these TODO’s are problematic and some of them are enhancements rather than potential corners. I would prioritize removing the most important ones first.\n"}]